package mpt.lab.three

import mpt.lab.two.lexem.LexType
import mpt.lab.three.Types.TLexem

/**
 * @author phpusr
 *         Date: 22.05.14
 *         Time: 16:07
 */

/**
 * Модуль описания матрицы предшествования и
 * правил грамматики
 */
object SyntRule {

  /** Состовляет основу */
  val Basis = '='
  /** Предшуствует */
  val Preceded = '<'
  /** Следует */
  val Follow = '>'
  /** Не сопоставимы */
  val Empty = ' '

  /** Матрица операторного предшествования */
  val GrammMatrix: Array[Array[Char]] = Array(
    Array(' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '>'), // ;
    Array(' ', ' ', '=', ' ', '<', ' ', '<', '<', '<', '<', ' ', ' '), // if
    Array('>', '<', ' ', '=', '<', ' ', ' ', ' ', ' ', ' ', ' ', ' '), // then
    Array('>', '<', ' ', '>', '<', ' ', ' ', ' ', ' ', ' ', ' ', ' '), // else
    Array('>', ' ', '>', '>', ' ', '=', '>', '>', '>', ' ', '>', ' '), // a
    Array('>', ' ', '>', '<', ' ', ' ', '<', '<', '<', '<', ' ', ' '), // :=
    Array('>', ' ', '>', '>', '<', ' ', '>', '>', '<', '<', '>', ' '), // <
    Array('>', ' ', '>', '>', '<', ' ', '>', '>', '<', '<', '>', ' '), // >
    Array('>', ' ', '>', '>', '<', ' ', '>', '>', '>', '<', '>', ' '), // ==
    Array(' ', ' ', ' ', ' ', '<', ' ', '<', '<', '<', '<', '=', ' '), // (
    Array('>', ' ', '>', '>', ' ', ' ', '>', '>', '>', ' ', '>', ' '), // )
    Array('<', '<', ' ', ' ', '<', ' ', ' ', ' ', ' ', ' ', ' ', ' ')  // Начало
  )

  val GrammRules: Array[String] = ???

  /** Корректировка отношения */
  def correctRule(cRule: Char, lexTCur: TLexem, lex: LexType, symbStack: TSymbStack): Char = cRule

  /** Наименование нетерминального символа в правилах остновной грамматики */
  def makeSymbolStr(ruleNum: Int): String = "E" //TODO вынести в константы

}
